#ifndef IRON_IRON_H
#define IRON_IRON_H

#include <stdio.h>
#include <stdlib.h>

template <typename T>
void _panic(const char *message)
{
  printf("Panic: %s\n", message);

  abort();
}

#define panic _panic<int>
template <typename T>
struct ref;

template <typename T>
struct val
{
  template <typename U>
  friend struct val;

  template <typename U>
  friend struct ref;

  /*
   * val
   */
  val() : mut() { }
  val(const val &copy) : mut(copy.mut.raw) { }
  val &operator=(const val &other) { reset(other.mut.raw); return *this; }
  ~val() { check(); }

  template <typename U>
  val(const val<U> &other) : mut(other.mut.raw) { }
  template <typename U>
  val &operator=(const val<U> &other) { reset(other.mut.raw); return *this; }

  /*
   * T
   */
  val(const T &value) : mut(value) { }
  val &operator=(const T &value) { reset(value); return *this; }

  template <typename U>
  val(U &value) : mut(value) { }
  template <typename U>
  val &operator=(U &value) { reset(value); return *this; }

  /*
   * operators
   */
  T &operator->() const { return mut.raw; }
  //T &operator*() const { return mut.raw; }
  operator T &() const { return mut.raw; }

private:

  mutable struct Mut
  {
    T raw;
    int count;

    Mut() : raw(), count() { }
    Mut(const T &raw) : raw(raw), count() { }
  } mut;

  void check() const
  {
    if(mut.count)
    {
      panic("Dangling references remain");
    }
  }

  void reset(const T &raw) const
  {
    mut.raw = raw;
  }

};

template <typename T>
struct ref;

template <typename T>
struct box
{
  /*
   * box
   */
  box() : mut() { }
  box(const box &copy) : mut(copy.mut.raw, copy.mut.deleter, copy.mut.count) { copy.release(); }
  box &operator=(const box &other) { if(&other != this) { reset(); mut = Mut(other.mut.raw, other.mut.deleter, other.mut.count); other.release(); } return *this; }
  ~box() { reset(); }

  template <typename U>
  box(const box<U> &other) : mut(other.mut.raw, other.mut.deleter, other.mut.count) { other.release(); }
  template <typename U>
  box &operator=(const box<U> &other) { if((void *)&other != (void *)this) { reset(); mut = Mut(other.mut.raw, other.mut.deleter, other.mut.count); other.release(); } return *this; }

  /*
   * operators
   */
  T *operator->() const { return get(); }
  //T &operator*() const { return *get(); }
  operator T *() const { return get(); }

  static box make()
  {
    box rtn;

    rtn.mut.raw = new T();
    rtn.mut.deleter = deleter;
    rtn.mut.count = new int();

    return rtn;
  }

  bool valid() const
  {
    return mut.raw;
  }

  T *get() const
  {
    if(!mut.raw)
    {
      panic("Accessing NULL pointer");
    }

    return mut.raw;
  }

  void reset() const
  {
    check();

    if(mut.deleter && mut.raw)
    {
      mut.deleter((void *)mut.raw);
    }

    if(mut.count)
    {
      delete mut.count;
    }

    release();
  }

private:
  template <typename U>
  friend struct ref;

  template <typename U>
  friend struct box;

  mutable struct Mut
  {
    T *raw;
    void (*deleter)(void *);
    int *count;

    Mut() : raw(), deleter(), count() { }
    Mut(T *const &raw, void (*const &deleter)(void *), int *const &count) : raw(raw), deleter(deleter), count(count) { }
  } mut;

  static void deleter(void *ptr)
  {
    T *t = (T *)ptr;
    delete t;
  }

  void check() const
  {
    if(mut.count && *mut.count)
    {
      panic("Dangling references remain");
    }
  }

  void release() const
  {
    mut.raw = NULL;
    mut.deleter = NULL;
    mut.count = NULL;
  }

};


template <typename T>
struct ref
{
  template <typename U>
  friend struct ref;

  /*
   * ref
   */
  ref() : mut() { }
  ref(const ref &copy) : mut() { reset(copy.mut.raw, copy.mut.count); }
  ref &operator=(const ref &other) { reset(other.mut.raw, other.mut.count); return *this; }
  ~ref() { reset(NULL, NULL); }

  template <typename U>
  ref(const ref<U> &other) : mut() { reset(other.mut.raw, other.mut.count); }
  template <typename U>
  ref &operator=(const ref<U> &other) { reset(other.mut.raw, other.mut.count); return *this; }

  /*
   * val
   */
  ref(const val<T> &value) : mut() { reset(&value.mut.raw, &value.mut.count); }
  ref &operator=(const val<T> &value) { reset(&value.mut.raw, &value.mut.count); return *this; }

  template <typename U>
  ref(const val<U> &value) : mut() { reset(&value.mut.raw, &value.mut.count); }
  template <typename U>
  ref &operator=(const val<U> &value) { reset(&value.mut.raw, &value.mut.count); return *this; }

  /*
   * box
   */
  ref(const box<T> &value) : mut() { reset(value.mut.raw, value.mut.count); }
  ref &operator=(const box<T> &value) { reset(value.mut.raw, value.mut.count); return *this; }

  template <typename U>
  ref(const box<U> &value) : mut() { reset(value.mut.raw, value.mut.count); }
  template <typename U>
  ref &operator=(const box<U> &value) { reset(value.mut.raw, value.mut.count); return *this; }

  /*
   * T
   */
  ref(const T &value) : mut() { *get() = value; }
  ref &operator=(const T &value) { *get() = value; return *this; }

  template <typename U>
  ref(const U &value) : mut() { *get() = value; }
  template <typename U>
  ref &operator=(const U &value) { *get() = value; return *this; }

  /*
   * operators
   */
  T *operator->() const { return get(); }
  T &operator*() const { return *get(); }
  operator T &() const { return *get(); }

private:
  mutable struct Mut
  {
    T *raw;
    int *count;

    Mut() : raw(), count() { }
  } mut;

  T *const &get() const
  {
    if(!mut.count)
    {
      panic("Accessing NULL reference");
    }

    return mut.raw;
  }

  void reset(T *const &raw, int *const &count) const
  {
    if(mut.count) (*mut.count)--;

    mut.raw = raw;
    mut.count = count;

    if(mut.count) (*mut.count)++;
  }

};
#include <new>

template <typename T>
struct vec
{
  vec() : curr(), max(), data() { }
  vec(vec const &copy) : curr(), max(), data() { clone(copy); }
  vec &operator=(vec const &other) { if(&other != this) { clone(other); } return *this; }
  ~vec() { wipe(); }

  size_t size() const { return curr; }

  void push(T const &value)
  {
    fit(curr + 1);
    new(&data[curr]) val<T>(value);
    ++curr;
  }

  ref<T> operator[](size_t idx) const
  { 
    if(idx >= curr)
    {
      panic("Index past end of vector");
    }

    return data[idx];
  }

  void clear()
  {
    for(size_t i = 0; i < curr; i++)
    {
      data[i].~val<T>();
    }

    curr = 0;
  }

private:
  size_t curr;
  size_t max;
  val<T> *data;

  void wipe()
  {
    if(!data) return;
 
    for(size_t i = 0; i < curr; i++)
    {
      data[i].~val<T>();
    }

    free(data); data = NULL;
    curr = 0;
    max = 0;
  }

  void fit(size_t req)
  {
    size_t nm = 8;

    if(max >= req) return;

    while(nm < req)
    {
      nm *= 2;
    }

    if(max >= nm) return;

    val<T> *nd = (val<T> *)malloc(nm * sizeof(val<T>));

    for(size_t i = 0; i < curr; i++)
    {
      new(&nd[i]) val<T>(data[i]);
    }

    size_t nc = curr;
    wipe();
    curr = nc;
    data = nd;
    max = nm;
  }

  void clone(vec const &copy)
  {
    wipe();
    fit(copy.curr);

    for(size_t i = 0; i < copy.curr; i++)
    {
      new(&data[i]) val<T>(copy.data[i]);
    }

    curr = copy.curr;
  }
};

#include <stdio.h>

struct freader
{
  freader() { }

  freader(const char *path)
  {
    open(path);
  }

  ~freader()
  {
    close();
  }

  void close()
  {
    if(!fp.valid()) return;

    fclose(*fp);
    fp = box<FILE *>();
  }

  void open(const char *path)
  {
    box<FILE *> fp = box<FILE *>::make();

    *fp = fopen(path, "r");

    if(!*fp)
    {
      throw std::exception();
    }

    close();
    this->fp = fp;
  }

  unsigned char getc()
  {
    int rtn = fgetc(*fp);

    if(rtn == EOF)
    {
      throw std::exception();
    }

    return rtn;
  }

  bool eof()
  {
    //if(feof(*fp))
    //{
    //  return true;
    //}

    int c = fgetc(*fp);

    if(c == EOF)
    {
      return true;
    }

    ungetc(c, *fp);

    return false;
  }

private:
  box<FILE *> fp;

};

#endif

